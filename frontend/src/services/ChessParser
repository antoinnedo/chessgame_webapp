export default class ChessParser {
  constructor() {
    // In the future, you could pass options here,
    // like language rules (e.g., { lang: 'es' })
  }

  /**
   * Normalizes and parses a spoken chess move.
   * @param {string} text - The raw spoken text.
   * @returns {string|null} The move in SAN notation or null if not found.
   */
  parse(text) {
    if (!text) return null;

    let normalizedText = text.toLowerCase()
      .replace(/\b(knight|night)\b/g, 'N')
      .replace(/\b(bishop)\b/g, 'B')
      .replace(/\b(rook|rock|look)\b/g, 'R')
      .replace(/\b(queen)\b/g, 'Q')
      .replace(/\b(king)\b/g, 'K')
      .replace(/\b(pawn)\b/g, '')
      .replace(/\b(one|1)\b/g, '1')
      .replace(/\b(two|to|too)\b/g, '2')
      .replace(/\b(three|tree)\b/g, '3')
      .replace(/\b(four|for)\b/g, '4')
      .replace(/\b(five|pipe)\b/g, '5')
      .replace(/\b(six|sex)\b/g, '6')
      .replace(/\b(seven)\b/g, '7')
      .replace(/\b(eight|ate)\b/g, '8')
      .replace(/\b(castle|castles)\b/g, 'O-O')
      .replace(/(\s|to)+/g, ''); // Remove all spaces and "to"

    const moveRegex = /\b([KQRBN]?[a-h]?[1-8]?x?[a-h][1-8](=[QRBN])?[+#]?|O-O-O|O-O)\b/gi;

    const matches = normalizedText.match(moveRegex);

    if (matches) {
      return matches[matches.length - 1];
    }

    return null;
  }
}